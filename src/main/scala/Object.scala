// quote:
//  https://scala-text.github.io/scala_text/object.html

/*
  Scalaでは、全ての値がオブジェクトである。また、全てのメソッドは何らかのオブジェクトに所属している
  objectキーワードによって、同じ名前のシングルトンオブジェクトを現在の名前空間の下に1つ定義できる
  objectキーワードによって定義したシングルトンオブジェクトには、そのオブジェクト固有のメソッドや
  フィールドを定義できる

  class キーワードで宣言したクラスの場合、そこから複数のインスタンスを生成することができるが、
  object キーワードで宣言されたクラスからは、ひとつのインスタンスしか生成することができない。これを
  シングルトンオブジェクト という

  object構文の主な用途としては、
    - ユーティリティメソッドやグローバルな状態の置き場所（Javaで言うstaticメソッドやフィールド）
    - 同名クラスのオブジェクトのファクトリメソッド
  が挙げられる

  objectの基本構文はクラスとおおむね同じで、次の通りである
    object <オブジェクト名> extends <クラス名> (with <トレイト名>)* {
      (<フィールド定義> | <メソッド定義>)*
    }

  - ユーティリティメソッドやグローバルな状態の置き場所（Javaで言うstaticメソッドやフィールド）
    Scalaでは標準でPredefというobjectが定義・インポートされており、これは最初の使い方に当てはまる
    println("Hello") となにげなく使っていたメソッドも実はPredef のメソッドである

    extends でクラスを継承、 with でトレイトをmix-in 可能になっているのは、オブジェクト名を既存の
    クラスのサブクラス等として振る舞わせたい場合があるからである

    Scala の標準ライブラリでは、 Nil という object があるが、これは List の一種として振る舞わせたい
    ため、 List を継承している。一方、 object がトレイトをmix-inする事はあまり多くないが、クラスや
    トレイトとの構文の互換性のためにそうなっていると思われる

  - 同名クラスのオブジェクトのファクトリメソッド
    点を表す Point クラスのファクトリを objectで作ろうとすると、次のようになる。apply という名前の
    メソッドはScala処理系によって特別に扱われ、Point(x)のような記述があった場合で、Point objectに
    applyという名前のメソッドが定義されていた場合、Point.apply(x)と解釈される。これを利用してPoint
    objectの applyメソッドでオブジェクトを生成するようにすることで、Point(3, 5)のような記述でオブ
    ジェクトを生成できるようになる

    これは、new Point()で直接Pointオブジェクトを生成するのに比べて、
      クラス（Point）の実装詳細を内部に隠しておける（インタフェースのみを外部に公開する）
      Pointではなく、そのサブクラスのインスタンスを返すことができる

    ケースクラスは、それをつけたクラスのプライマリコンストラクタ全てのフィールドを公開し、equals()・
    hashCode()・toString()などのオブジェクトの基本的なメソッドをオーバーライドしたクラスを生成し、
    また、そのクラスのインスタンスを生成するためのファクトリメソッドを生成する
 */

class PointA(val x: Int, val y: Int)

object PointA {
  def apply(x: Int, y: Int): PointA = new PointA(x, y)
}

case class PointB(x: Int, y: Int)

object Object {
  def main(args: Array[String]): Unit = {
    PointA(3, 5)
    PointB(3, 5)
  }
}
